<script type="text/javascript">
  
    //this was previously in mousemove event
    if (selectedDraggable != undefined) { //if anything selected, move it by its center
      selectedDraggable.x = mouseX - selectedDraggable.element.image.width/2;
      selectedDraggable.y = mouseY - selectedDraggable.element.image.height/2;
    }
    else if (selectedGUIElement != undefined){
      selectedDraggable = createSprite(selectedGUIElement.name);
      selectedGUIElement = undefined;
    }

  var selectedDraggable; //which draggable element is currently being dragged
  var selectedGUIElement; //which gui element is selected;
  canvas.addEventListener("mousedown", function(e) {
    selectedDraggable = onScreen.filter(function(e) { return checkSprite(e, mouseX, mouseY); }); //find all elements that the mouse is over
    if (selectedDraggable.length != 0) { //if anything found
      selectedDraggable = selectedDraggable[0]; //take first selected in list
      //move to front of onScreen:
      for (var i = onScreen.indexOf(selectedDraggable); i > 0; --i) { //run through list
        onScreen[i] = onScreen[i-1]; //shift everything down one to the right
      }
      onScreen[0] = selectedDraggable; //replace first item
    } else {
      selectedDraggable = undefined; //nothing selected
	  selectedGUIElement = getGUIElement(mouseX, mouseY);
	  //TODO ROBBIE create getGUIElement(mouseX, mouseY) function
    }
  });
  canvas.addEventListener("mouseup", function(e) {
    if(selectedDraggable != undefined) { //if anything selected
      if (!checkForDeletion(mouseX, mouseY)){
        selectedDraggable.checkCollisions(); //check if collision
      }
      selectedDraggable = undefined; //set to nothing selected
    }
    selectedGUIElement = undefined;
  });
  canvas.addEventListener("mousemove", function(e) {
    mouseX = e.offsetX;
    mouseY = e.offsetY;
    if (selectedDraggable != undefined) { //if anything selected, move it by its center
      selectedDraggable.x = mouseX - selectedDraggable.element.image.width/2;
      selectedDraggable.y = mouseY - selectedDraggable.element.image.height/2;
    }
    else if (selectedGUIElement != undefined){
      selectedDraggable = createSprite(selectedGUIElement.name);
      selectedGUIElement = undefined;
    }
  });
  canvas.addEventListener("mouseout", function(e) {
    if(selectedDraggable != undefined) { //if anything selected
      if (!checkForDeletion(mouseX, mouseY)){
        selectedDraggable.checkCollisions(); //check if collision
      }
      selectedDraggable = undefined; //set to nothing selected
    }
    selectedGUIElement = undefined;
  });

  function Draggable(name) {
    //see canvas event listeners, which use this class
    this.element = elementByName(name);
    this.x = mouseX - (imageSize / 2);
    this.y = mouseY - (imageSize / 2);
    var o_this = this; //o_this --> "outer this" - used in internal function calls, since they have their own "this"
    this.collide = function(other) { //collide with other. Returns true if valid
      var combined = o_this.element.combine(other.element); //find new element
      if (combined != undefined) { //if new element exists (valid formula)
        //console.log(o_this.element.name + "+" + other.element.name + "=" + combined.name); //log formula in console
        this.element = combined; //set this Draggable's element to the new element
        if (!combined.unlocked) { //if we haven't unlocked the new element yet, unlock it
          combined.unlocked = true;
        }
        onScreen.splice(onScreen.indexOf(other), 1); //remove other element from screen
        return true;
      }
      return false;
    };
    this.checkCollide = function(other) { //checks if this collides with other using circular hitboxes. 
      //Currently assumes width=height and that both are same size - We can fix this later
      return (other != o_this && Math.hypot(other.x - o_this.x, other.y - o_this.y) < other.element.image.width);
    }
    this.draw = function() {
      context.drawImage(o_this.element.image, o_this.x, o_this.y, o_this.element.image.width, o_this.element.image.height);
    };
    this.checkCollisions = function() { //checks for collisions, and first valid collision found (valid pos, valid formula) gets applied and check stops
      for(var i = 0; i < onScreen.length; ++i) { //check all collisions from front to back
        var item = onScreen[i];
        if (o_this.checkCollide(item)) { //collide pos is right
          if (o_this.collide(item)) {
            return; //only collide with one and then stop
          }
        }
      }
    }
  }

  function checkForDeletion(mouseX, mouseY) {
    var guiYBorder = canvas.height - guiHeight;
    if(mouseY >= guiYBorder){
      return removeSelectedSprite();
    }
    return false;
  }
  function removeSelectedSprite() {
    if (selectedDraggable != undefined) {
      onScreen.splice(0, 1);
      return true;
    }
    return false;
  }
  
  function getGUIElement(mouseX, mouseY){
    console.log("mouse: (" + mouseX + "," + mouseY + ")");
    for (var i = 0; i < elements.length; i++){
      var e = elements[i];
      if (e.unlocked) {
      
        var boundX1 = 0 + imageSize*(i%Math.floor(guiWidth/imageSize));
        var boundY1 = canvas.height - guiHeight + (imageSize+sepWidth)*Math.floor(i/Math.floor(guiWidth/imageSize));
        
        //var boundX1 = 0 + (imageSize * i)
        var boundX2 = boundX1 + imageSize;
        //var boundY1 = canvas.height - guiHeight;
        var boundY2 = boundY1 + imageSize;
        console.log("" + e.name + ":(" + boundX1 + "," + boundY1 + ") (" + boundX2 + "," + boundY2 + ")");
        if(mouseX >= boundX1 && mouseX <= boundX2){
          //console.log("truex" + e.name);
          if(mouseY >= boundY1 && mouseY <= boundY2){
            //console.log("truey" + e.name);
            console.log(e.name + " selected");
            return e;
          }
        }
      }
    }
  }
  
  function createSprite(name){
    var created = new Draggable(name);
    onScreen.unshift(created);
    return created;
  }
