<canvas id="canvas" width="576" height="450">
  Canvas not supported
</canvas>
<script type="text/javascript">
  var mouseX, mouseY;
  var mousePressed = false;
  
  function Game(canvas) {
    this.mouseX = 0;
    this.mouseY = 0;
    this.mousePressed = false;
    var self = this;
    canvas.addEventListener("mousemove", function(e) {
      this.mouseX = e.offsetX;
      this.mouseY = e.offsetY;
      self.mouseMove();
    });
    
    this.canvas = canvas;
    this.context = canvas.getContext('2d');
    this.gameTree = [];
    this.guiTree = [];
    this.timer = undefined;
  }
  
  Game.prototype.drawGui = function() {
  }
  
  Game.prototype.mouseMove = function() {
  }
  
  Game.prototype.drawMain = function() {
  }
  
  Game.prototype.draw() = function() {
    this.drawMain();
    this.drawGui();
  }
  
  Game.prototype.update = function () {
    //override
  }
  
  Game.prototype.loop = function() {
    this.update();
    this.draw();
  }
      
  Game.prototype.start = function(milliseconds) {
    self.timer.setInterval(self.loop, milliseconds);
  }
  Game.prototype.stop = function() {
    if (self.timer != undefined) {
      clearInterval(self.timer);
    }
  }
  
  function Sprite(name, width, height, src) {
    this.image = new Image();
    this.image.src = src;
    this.image.width = width;
    this.image.height = height;
    this.name = name;
    function draw(game, x, y) {
      game.context.drawImage(self.image, x, y, self.image.width, self.image.height);
    }
  }
  
  function FilledRectSprite(name, width, height, fillStyle) { //can use in place of sprite. fillStyle can be color, gradient, pattern
    this.width = width;
    this.height = height;
    this.name = name;
    this.fillStyle = fillStyle;
    var self;
    function draw(game, x, y) {
      var saveContext = false;
      if (game.context.fillStyle == self.fillStyle) {
        saveContext = true;
        game.context.save();
      }
      game.context.fillStyle = self.fillStyle;
      game.context.fillRect(x, y, self.width, self.height);
      if (saveContext) {
        game.context.restore();
      }
    }
  }
  
  function Object(game, name, sprite, x, y, setupFunction, xOffset = 0, yOffset = 0) {
    var self = this;
    this.sprite = sprite;
    this.x = x;
    this.y = y;
    this.xOffset = xOffset; //TODO use this
    this.yOffset = yOffset; //TODO use this
    this.game = game;
    this.name = name;
    if (setupFunction) {
      setupFunction(self);
    }
    function update() {
      
    }
    function draw(game) {
      if (self.sprite != undefined) {
        self.sprite.draw(game, self.x, self.y);
      }
    }
  }
  
  function parseFile(file, lineTransformer) {
    //lineTransformer is a function that takes a line as an input and then does something with it
    //TODO
  }

  //checks collision with coordinate. taken from code we used in class
  //returns true if (x, y) is contained in sprite (assumes rectangular bounding box)
  function checkSpriteRect(sprite, x, y) {
    var minX = sprite.x;
    var maxX = sprite.x + sprite.element.image.width;
    var minY = sprite.y;
    var maxY = sprite.y + sprite.element.image.height;
    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
      return true;
    }
    return false;
  }
  
  
  //above this comment is code that would go in separate file
  
  var game = new Game(document.getElementById("canvas"));
  game.start(30);
  
  
  var imageSize = 64;
  
  function Element(game, src, size, name, unlocked) {
    return new Object(game, name, Sprite(name, size, size, src), mouseX, mouseY, function(obj) { 
      obj.unlocked = unlocked;
      this.interactions = {};
      this.link = function(element2, element3) {
        obj.interactions[element2.name] = element3;
        element2.interactions[obj.name] = element3;
      }
      this.combine = function(element2) {
        return obj.interactions[element2.name];
      }
    });
  }
  
  //below this comment is unrefactored code
  //TODO transforms eventually maybe
  
    //this was previously in mousemove event
    if (selectedDraggable != undefined) { //if anything selected, move it by its center
      selectedDraggable.x = mouseX - selectedDraggable.element.image.width/2;
      selectedDraggable.y = mouseY - selectedDraggable.element.image.height/2;
    }
    else if (selectedGUIElement != undefined){
      selectedDraggable = createSprite(selectedGUIElement.name);
      selectedGUIElement = undefined;
    }
  
  var elements = new Array();
  var onScreen = new Array(); //elements on main screen
  
  var imageSize = 64;
  var numRows = 3;
  //width of the gui
  var guiWidth = canvas.width;
  var sepWidth = 3;
  //height of the gui
  var guiHeight = numRows * imageSize + ((numRows - 1) * sepWidth);

  function elementByName(name) { //get element by name
    temp = elements.filter(function(e) { return e.name == name; });
    if (temp.length == 0) { //doesn't exist
      return null;
    } else {
      return temp[0]; //return first element with name - should only be one
    }
  }

  //link elements so element1+element2=element3
  function linkByName(element1, element2, element3) {
    elementByName(element1).link(elementByName(element2), elementByName(element3));
  }

  var selectedDraggable; //which draggable element is currently being dragged
  var selectedGUIElement; //which gui element is selected;
  canvas.addEventListener("mousedown", function(e) {
    selectedDraggable = onScreen.filter(function(e) { return checkSprite(e, mouseX, mouseY); }); //find all elements that the mouse is over
    if (selectedDraggable.length != 0) { //if anything found
      selectedDraggable = selectedDraggable[0]; //take first selected in list
      //move to front of onScreen:
      for (var i = onScreen.indexOf(selectedDraggable); i > 0; --i) { //run through list
        onScreen[i] = onScreen[i-1]; //shift everything down one to the right
      }
      onScreen[0] = selectedDraggable; //replace first item
    } else {
      selectedDraggable = undefined; //nothing selected
	  selectedGUIElement = getGUIElement(mouseX, mouseY);
	  //TODO ROBBIE create getGUIElement(mouseX, mouseY) function
    }
  });
  canvas.addEventListener("mouseup", function(e) {
    if(selectedDraggable != undefined) { //if anything selected
      if (!checkForDeletion(mouseX, mouseY)){
        selectedDraggable.checkCollisions(); //check if collision
      }
      selectedDraggable = undefined; //set to nothing selected
    }
    selectedGUIElement = undefined;
  });
  canvas.addEventListener("mousemove", function(e) {
    mouseX = e.offsetX;
    mouseY = e.offsetY;
    if (selectedDraggable != undefined) { //if anything selected, move it by its center
      selectedDraggable.x = mouseX - selectedDraggable.element.image.width/2;
      selectedDraggable.y = mouseY - selectedDraggable.element.image.height/2;
    }
    else if (selectedGUIElement != undefined){
      selectedDraggable = createSprite(selectedGUIElement.name);
      selectedGUIElement = undefined;
    }
  });
  canvas.addEventListener("mouseout", function(e) {
    if(selectedDraggable != undefined) { //if anything selected
      if (!checkForDeletion(mouseX, mouseY)){
        selectedDraggable.checkCollisions(); //check if collision
      }
      selectedDraggable = undefined; //set to nothing selected
    }
    selectedGUIElement = undefined;
  });

  function Draggable(name) {
    //see canvas event listeners, which use this class
    this.element = elementByName(name);
    this.x = mouseX - (imageSize / 2);
    this.y = mouseY - (imageSize / 2);
    var o_this = this; //o_this --> "outer this" - used in internal function calls, since they have their own "this"
    this.collide = function(other) { //collide with other. Returns true if valid
      var combined = o_this.element.combine(other.element); //find new element
      if (combined != undefined) { //if new element exists (valid formula)
        //console.log(o_this.element.name + "+" + other.element.name + "=" + combined.name); //log formula in console
        this.element = combined; //set this Draggable's element to the new element
        if (!combined.unlocked) { //if we haven't unlocked the new element yet, unlock it
          combined.unlocked = true;
        }
        onScreen.splice(onScreen.indexOf(other), 1); //remove other element from screen
        return true;
      }
      return false;
    };
    this.checkCollide = function(other) { //checks if this collides with other using circular hitboxes. 
      //Currently assumes width=height and that both are same size - We can fix this later
      return (other != o_this && Math.hypot(other.x - o_this.x, other.y - o_this.y) < other.element.image.width);
    }
    this.draw = function() {
      context.drawImage(o_this.element.image, o_this.x, o_this.y, o_this.element.image.width, o_this.element.image.height);
    };
    this.checkCollisions = function() { //checks for collisions, and first valid collision found (valid pos, valid formula) gets applied and check stops
      for(var i = 0; i < onScreen.length; ++i) { //check all collisions from front to back
        var item = onScreen[i];
        if (o_this.checkCollide(item)) { //collide pos is right
          if (o_this.collide(item)) {
            return; //only collide with one and then stop
          }
        }
      }
    }
  }

  function checkForDeletion(mouseX, mouseY){
    var guiYBorder = canvas.height - guiHeight;
    if(mouseY >= guiYBorder){
      return removeSelectedSprite();
    }
    return false;
  }
  function removeSelectedSprite(){
    if (selectedDraggable != undefined) {
      onScreen.splice(0, 1);
      return true;
    }
    return false;
  }
  
  function getGUIElement(mouseX, mouseY){
    console.log("mouse: (" + mouseX + "," + mouseY + ")");
    for (var i = 0; i < elements.length; i++){
      var e = elements[i];
      if (e.unlocked) {
      
        var boundX1 = 0 + imageSize*(i%Math.floor(guiWidth/imageSize));
        var boundY1 = canvas.height - guiHeight + (imageSize+sepWidth)*Math.floor(i/Math.floor(guiWidth/imageSize));
        
        //var boundX1 = 0 + (imageSize * i)
        var boundX2 = boundX1 + imageSize;
        //var boundY1 = canvas.height - guiHeight;
        var boundY2 = boundY1 + imageSize;
        console.log("" + e.name + ":(" + boundX1 + "," + boundY1 + ") (" + boundX2 + "," + boundY2 + ")");
        if(mouseX >= boundX1 && mouseX <= boundX2){
          //console.log("truex" + e.name);
          if(mouseY >= boundY1 && mouseY <= boundY2){
            //console.log("truey" + e.name);
            console.log(e.name + " selected");
            return e;
          }
        }
      }
    }
  }
  
  function createSprite(name){
    var created = new Draggable(name);
    onScreen.unshift(created);
    return created;
  }

  function setup() {
    elements.push(new Element("wings", "http://www4.ncsu.edu/~ztbrownl/images/wings.png", imageSize, imageSize, true));
    elements.push(new Element("scales", "http://www4.ncsu.edu/~ztbrownl/images/scales.png", imageSize, imageSize, true));
    elements.push(new Element("fur", "http://www4.ncsu.edu/~ztbrownl/images/fur.png", imageSize, imageSize, true));
    elements.push(new Element("skin", "http://www4.ncsu.edu/~ztbrownl/images/skin.png", imageSize, imageSize, true));
    elements.push(new Element("horn", "http://www4.ncsu.edu/~ztbrownl/images/horn.png", imageSize, imageSize, true));
    elements.push(new Element("water", "http://www4.ncsu.edu/~ztbrownl/images/water.png", imageSize, imageSize, true));
    elements.push(new Element("hair", "http://www4.ncsu.edu/~ztbrownl/images/hair.png", imageSize, imageSize, false));
    elements.push(new Element("bird", "http://www4.ncsu.edu/~ztbrownl/images/bird.png", imageSize, imageSize, false));
    elements.push(new Element("snake", "http://www4.ncsu.edu/~ztbrownl/images/snake.png", imageSize, imageSize, false));
    elements.push(new Element("dragon", "http://www4.ncsu.edu/~ztbrownl/images/dragon.png", imageSize, imageSize, false));
    elements.push(new Element("human", "http://www4.ncsu.edu/~ztbrownl/images/human.png", imageSize, imageSize, false));
    elements.push(new Element("fish", "http://www4.ncsu.edu/~ztbrownl/images/fish.png", imageSize, imageSize, false))
    elements.push(new Element("horse", "http://www4.ncsu.edu/~ztbrownl/images/horse.png", imageSize, imageSize, false))
    elements.push(new Element("lion", "http://www4.ncsu.edu/~ztbrownl/images/lion.png", imageSize, imageSize, false))
    elements.push(new Element("bull", "http://www4.ncsu.edu/~ztbrownl/images/bull.png", imageSize, imageSize, false))
    elements.push(new Element("unicorn", "http://www4.ncsu.edu/~alrichma/images/unicorn.png", imageSize, imageSize, false))
    elements.push(new Element("griffin", "http://www4.ncsu.edu/~alrichma/images/griffin.png", imageSize, imageSize, false))
    elements.push(new Element("werewolf", "http://www4.ncsu.edu/~alrichma/images/werewolf.png", imageSize, imageSize, false))
    elements.push(new Element("pegasus", "http://www4.ncsu.edu/~ztbrownl/images/pegasus.png", imageSize, imageSize, false))
    elements.push(new Element("sphinx", "http://www4.ncsu.edu/~alrichma/images/sphinx.png", imageSize, imageSize, false))
    elements.push(new Element("mermaid", "http://www4.ncsu.edu/~alrichma/images/mermaid.png", imageSize, imageSize, false))
    elements.push(new Element("minotaur", "http://www4.ncsu.edu/~alrichma/images/minotar.png", imageSize, imageSize, false))
    elements.push(new Element("centaur", "http://www4.ncsu.edu/~alrichma/images/centaur.png", imageSize, imageSize, false))
    elements.push(new Element("medusa", "http://www4.ncsu.edu/~alrichma/images/medusa.png", imageSize, imageSize, false))
    elements.push(new Element("harpy", "http://www4.ncsu.edu/~alrichma/images/harpy.png", imageSize, imageSize, false))
    elements.push(new Element("manticore", "http://www4.ncsu.edu/~ztbrownl/images/manticore.png", imageSize, imageSize, false))
    linkByName("scales", "fur", "hair")
    linkByName("wings", "wings", "bird")
    linkByName("scales", "scales", "snake")
    linkByName("wings", "scales", "dragon")
    linkByName("snake", "wings", "dragon")
    linkByName("skin", "hair", "human")
    linkByName("water", "scales", "fish")
    linkByName("fur", "hair", "horse")
    linkByName("fur", "fur", "lion")
    linkByName("fur", "horn", "bull")
    linkByName("human", "fur", "werewolf")
    linkByName("horse", "wings", "pegasus")
    linkByName("horn", "horse", "unicorn")
    linkByName("bird", "lion", "griffin")
    linkByName("human", "lion", "sphinx")
    linkByName("human", "fish", "mermaid")
    linkByName("human", "bull", "minotaur")
    linkByName("human", "horse", "centaur")
    linkByName("human", "snake", "medusa")
    linkByName("human", "bird", "harpy")
    linkByName("sphinx", "dragon", "manticore")
  }

  function update() {
    //TODO Dunno if we actually need any updates
  }

  function draw() {
    canvas.width = canvas.width; //clears the canvas
    //drawDebugText();
    context.fillStyle = "black";
    context.font = "bold 12px Arial";
    context.fillText("Place items here", 0, 10);
    
    drawGUI();
    for(var i = onScreen.length - 1; i >= 0; --i) { //go backwards through list, as front is most recent
      onScreen[i].draw();
    }
  }
	
	function drawGUI(){
		//draw the bars
		context.fillStyle="#AAAAAA";
		context.fillRect(0, canvas.height - guiHeight, guiWidth, guiHeight); //Draw Big rectangle
		context.fillStyle="#BBBBBB";
		for( var i = 1; i <= numRows - 1; i++){
			var startHeight = canvas.height - guiHeight + (i * imageSize) + ((i-1) * sepWidth);
			//Draw little separation rectangles
			context.fillRect(0,  startHeight, canvas.width, sepWidth);
		}
		//draw the elements	
		var x = 0;
		var y = canvas.height - guiHeight;
		
		context.fillStyle = "black";
		context.font = "bold 12px Arial";
		
		for( var i = 0; i < elements.length; i++ ){
			var e = elements[i];
      var xpos = x + imageSize*(i%Math.floor(guiWidth/imageSize));
      var ypos = y + (imageSize+sepWidth)*Math.floor(i/Math.floor(guiWidth/imageSize));
      
			context.drawImage(e.image, xpos, ypos, imageSize, imageSize);
      if (!e.unlocked) {
        context.globalAlpha=0.5;
        context.fillRect(xpos, ypos, imageSize, imageSize);
        context.globalAlpha=1;
      }
		}
	}

  setup();
</script>
