<canvas id="canvas" width="600" height="450">
  Canvas not supported
</canvas>
<script type="text/javascript">
  canvas = document.getElementById("canvas");
  context = canvas.getContext('2d');

  var elements = new Array();
  var onScreen = new Array(); //elements on main screen
  var unlocked = new Array();
  
  var imageSize = 64;
  var numRows = 3;
  //width of the gui
  var guiWidth = canvas.width;
  var sepWidth = 3;
  //height of the gui
  var guiHeight = numRows * imageSize + ((2 + numRows) * sepWidth);

  //The different elements we'll be mixing with alchemy
  function Element(name, src, width, height, unlocked = false) {
    this.name = name;
    this.unlocked = unlocked;
    this.interactions = {}; //stuff that it combines with to make other stuff
    this.image = new Image();
    this.image.src = src;
    this.image.width = width;
    this.image.height = height;
    var element = this;
    this.link = function(element2, element3) {
      element.interactions[element2.name] = element3;
      element2.interactions[element.name] = element3;
    }
    this.combine = function(element2) {
      return element.interactions[element2.name];
    }
		this.drawImage = function(x, y) {
			context.fillText("Drawing image", 0, 30);
			var newImage = new Image();
			newImage.src = "http://www4.ncsu.edu/~rnpettit/csc481/la/fire.png";
			newImage.width = 64;
			newImage.height = 64;
      //context.drawImage(newImage, 100, 100, this.width, this.height);
			context.fillText("Done", 0, 40);
    };
  }

  function elementByName(name) { //get element by name
    temp = elements.filter(function(e) { return e.name == name; });
    if (temp.length == 0) { //doesn't exist
      return null;
    } else {
      return temp[0]; //return first element with name - should only be one
    }
  }

  //link elements so element1+element2=element3
  function linkByName(element1, element2, element3) {
    elementByName(element1).link(elementByName(element2), elementByName(element3));
  }


//checks collision. taken from code we used in class
//returns true if (x, y) is contained in sprite (assumes rectangular bounding box)
  function checkSprite(sprite, x, y) {
    var minX = sprite.x;
    var maxX = sprite.x + sprite.element.image.width;
    var minY = sprite.y;
    var maxY = sprite.y + sprite.element.image.height;
    var mx = x;
    var my = y;
    //console.log(minX + " " + maxX);
    if (mx >= minX && mx <= maxX && my >= minY && my <= maxY) {
      return true;
    }
    return false;
  }

  var mouseX, mouseY;
  var selectedDraggable; //which draggable element is currently being dragged
  var selectedGUIElement; //which gui element is selected;
  canvas.addEventListener("mousedown", function(e) {
    selectedDraggable = onScreen.filter(function(e) { return checkSprite(e, mouseX, mouseY); }); //find all elements that the mouse is over
    if (selectedDraggable.length != 0) { //if anything found
      selectedDraggable = selectedDraggable[0]; //take first selected in list
      //move to front of onScreen:
      for (var i = onScreen.indexOf(selectedDraggable); i > 0; --i) { //run through list
        onScreen[i] = onScreen[i-1]; //shift everything down one to the right
      }
      onScreen[0] = selectedDraggable; //replace first item
    } else {
      selectedDraggable = undefined; //nothing selected
	  selectedGUIElement = getGUIElement(mouseX, mouseY);
	  //TODO ROBBIE create getGUIElement(mouseX, mouseY) function
    }
  });
  canvas.addEventListener("mouseup", function(e) {
    if(selectedDraggable != undefined) { //if anything selected
      selectedDraggable.checkCollisions(); //check if collision
      selectedDraggable = undefined; //set to nothing selected
    }
	selectedGUIElement = undefined;
  });
  canvas.addEventListener("mousemove", function(e) {
    mouseX = e.offsetX;
    mouseY = e.offsetY;
    if (selectedDraggable != undefined) { //if anything selected, move it by its center
      selectedDraggable.x = mouseX - selectedDraggable.element.image.width/2;
      selectedDraggable.y = mouseY - selectedDraggable.element.image.height/2;
    }
	else if (selectedGUIElement != undefined){
		selectedDraggable = createSprite(selectedGUIElement.name);
		selectedGUIElement = undefined;
	}
  });
  canvas.addEventListener("mouseout", function(e) {
    if(selectedDraggable != undefined) { //if anything selected
      selectedDraggable.checkCollisions(); //check if collision
      selectedDraggable = undefined; //set to nothing selected
    }
  });

  //TEMP
  //Adds a fire and water upon pressing any key
  document.addEventListener("keydown", function(e){ 
	createSprite("water");
	createSprite("fire"); 
	});

  function Draggable(name) {
    //see canvas event listeners, which use this class
    this.element = elementByName(name);
    this.x = mouseX - (imageSize / 2);
    this.y = mouseY - (imageSize / 2);
    var o_this = this; //o_this --> "outer this" - used in internal function calls, since they have their own "this"
    this.collide = function(other) { //collide with other. Returns true if valid
      var combined = o_this.element.combine(other.element); //find new element
      if (combined != undefined) { //if new element exists (valid formula)
        //console.log(o_this.element.name + "+" + other.element.name + "=" + combined.name); //log formula in console
        this.element = combined; //set this Draggable's element to the new element
        if (!combined.unlocked) { //if we haven't unlocked the new element yet, unlock it
          combined.unlocked = true;
          unlocked.push(combined)
        }
        onScreen.splice(onScreen.indexOf(other), 1); //remove other element from screen
        return true;
      }
      return false;
    };
    this.checkCollide = function(other) { //checks if this collides with other using circular hitboxes. 
      //Currently assumes width=height and that both are same size - We can fix this later
      return (other != o_this && Math.hypot(other.x - o_this.x, other.y - o_this.y) < other.element.image.width);
    }
    this.draw = function() {
      context.drawImage(o_this.element.image, o_this.x, o_this.y, o_this.element.image.width, o_this.element.image.height);
    };
    this.checkCollisions = function() { //checks for collisions, and first valid collision found (valid pos, valid formula) gets applied and check stops
      for(var i = 0; i < onScreen.length; ++i) { //check all collisions from front to back
        var item = onScreen[i];
        if (o_this.checkCollide(item)) { //collide pos is right
          if (o_this.collide(item)) {
            return; //only collide with one and then stop
          }
        }
      }
    }
  }

  
  
  function getGUIElement(mouseX, mouseY){
  console.log("mouse: (" + mouseX + "," + mouseY + ")");
	for (var i = 0; i < elements.length; i++){
		var e = elements[i];
		var boundX1 = 0 + (imageSize * i)
		var boundX2 = boundX1 + imageSize;
		var boundY1 = canvas.height - guiHeight;
		var boundY2 = boundY1 + imageSize;
		console.log("" + e.name + ":(" + boundX1 + "," + boundY1 + ") (" + boundX2 + "," + boundY2 + ")");
		if(mouseX >= boundX1 && mouseX <= boundX2){
			//console.log("truex" + e.name);
			if(mouseY >= boundY1 && mouseY <= boundY2){
				//console.log("truey" + e.name);
				console.log(e.name + " selected");
				return e;
			}
		}
	}
  }
  
  function createSprite(name){
	var created = new Draggable(name);
	onScreen.unshift(created);
	return created;
  }

  function setup() {
    elements.push(new Element("fire", "http://www4.ncsu.edu/~rnpettit/csc481/la/fire.png", imageSize, imageSize, true));
    elements.push(new Element("water", "http://www4.ncsu.edu/~rnpettit/csc481/la/water.png", imageSize, imageSize, true));
    elements.push(new Element("steam", "http://www4.ncsu.edu/~rnpettit/csc481/la/steam.png", imageSize, imageSize, false));
    linkByName("fire", "water", "steam");
    unlocked = elements.filter(function(e) { return e.unlocked; });
  }

  function update() {
    //TODO Dunno if we actually need any updates
  }

  function draw() {
    canvas.width = canvas.width; //clears the canvas
    drawDebugText();
    
    drawGUI();
    for(var i = onScreen.length - 1; i >= 0; --i) { //go backwards through list, as front is most recent
      onScreen[i].draw();
    }
  }
	
	function drawGUI(){
		 

		//draw the bars
		context.fillStyle="#AAAAAA";
		context.fillRect(0, canvas.height - guiHeight, guiWidth, guiHeight); //Draw Big rectangle
		context.fillStyle="#BBBBBB";
		for( var i = 1; i <= numRows - 1; i++){
			var startHeight = canvas.height - guiHeight + (i * imageSize) + (i * sepWidth);
			//Draw little separation rectangles
			context.fillRect(0,  startHeight, canvas.width, 3 + sepWidth);
		}
		//draw the elements	
		var x = 0;
		var y = canvas.height - guiHeight;
		
		context.fillStyle = "black";
		context.font = "bold 12px Arial";
		
		for( var i = 0; i < elements.length; i++ ){
			var e = elements[i];
			context.drawImage(e.image, x + (imageSize * i), y , imageSize, imageSize);
		}
	}
	
    //DEBUG TEXT//
    //provides a frame counter so we know that draw() is updating
  var frameNum = 0;
  function drawDebugText(){
    context.fillStyle = "black";
    context.font = "bold 12px Arial";
    context.fillText("Frame: " + frameNum, 0, 10);
    frameNum++;
  }

  function game_loop() {
    update();
    draw();
  }

  setup();
  setInterval(game_loop, 30);
</script>
