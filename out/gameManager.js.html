<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: gameManager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: gameManager.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** A game manager that will run any updates that you need to keep track of. Also it keeps track of levels.
  * @class
  * @namespace GameManager
  * @property {boolean} isCollidable - value if the object can be collided with. Defaults false.
  * @property {int} level - the current level of the game. Defaults zero. 
  * @property {array} events - the array of events to be carried out by the game manager.
  */
function GameManager(){
	var self = this;
	/** Creates the game manager object
	  * @constructs GameManager
	  */
	self.constructor = function() {
    GameObject.call(self, "GameManager", null, 0, 0);
    self.isCollidable=false;
    self.level = 0;
    self.events = [];
  }
  /** Creates GameManager */
  self.constructor();
  /** Override this function to put in your custom Updates for your game. Called before update.
	  * @memberof GameManager
	  * @param {game} game - The game object
	  */
  self.customUpdate = function(game){}
  /** The update function of the object. Do not override this function.
	  * @memberof GameManager
	  * @param {game} game - The game object
	  */
  self.update = function(game) {
    self.customUpdate(game);
    for (var i = self.events.length - 1; i >= 0; --i) {
      //console.log(self.events[i]);
      if (self.events[i].type == "timed") {
        //console.log(self.events[i].steps);
        if (--self.events[i].steps &lt;= 0) {
          //console.log("success!");
          self.events[i].func();
          if (self.events[i].repeat) {
            if (self.events[i].random) {
              self.events[i].steps = self.events[i].orig();
            } else {
              self.events[i].steps = self.events[i].orig;
            }
            //console.log("schedule")
          } else {
            self.events.splice(i, 1);
            //console.log("deleted event")
          }
        }
      } else if (self.events[i].type == "condition" &amp;&amp; !self.events[i].coolingDown) {
        //console.log("condition");
        if (self.events[i].cond()) {
          //console.log("success!");
          if (!(self.events[i].runFuncAtEndOfCooldown &amp;&amp; (self.events[i].random || self.events[i].cooldown))) {
            self.events[i].func();
            //console.log("called function");
          }
          if ((self.events[i].repeat || self.events[i].runFuncAtEndOfCooldown) &amp;&amp; (self.events[i].random || self.events[i].cooldown)) {
            //console.log("schedule")
            self.events[i].coolingDown = true;
            var event = self.events[i];
            if (!self.events[i].random) {
              self.addTimedEvent(self.events[i].cooldown, function() {if (event.runFuncAtEndOfCooldown) {event.func();} event.coolingDown = false;}, false);
            } else {
              self.addRandomTimedEvent(self.events[i].cooldownStart, self.events[i].cooldownEnd, function() {if (event.runFuncAtEndOfCooldown) {event.func();} event.coolingDown = false;}, false)
            }
          }
          if (!self.events[i].repeat) {
            self.events.splice(i, 1);
            //console.log("deleted event");
          }
        }
      }
    }
  }
  /**
   * Calls the events that run at the end of the update
   * @memberof GameManager
   */
  self.postUpdate = function() {
    for (var i = self.postEvents.length - 1; i >= 0; --i) {
      self.postEvents[i].func();
      if (!self.postEvents[i].repeat) {
        self.postEvents.splice(i, 1);
      }
    }
  }
  /** 
    * Adds a timed event to the game manager. Can trigger just once or repeatedly.
	  * @memberof GameManager
	  * @param {int} steps - how often to run the event
    * @param {function} func - the function to call when the event occurs
    * @param {boolean} repeat - whether or not to repeat the event after it occurs
	  */
  self.addTimedEvent = function(steps, func, repeat) {
    self.events.push({type: "timed", random: false, steps: steps, func: func, repeat: repeat, orig: steps});
  }
  /** 
    * Adds a randomly timed event to the game manager. Can trigger just once or repeatedly.
	  * @memberof GameManager
	  * @param {int} randomStart - how often to run the event at minimum
    * @param {int} randomEnd - how often to run the event at maximum
    * @param {function} func - the function to call when the event occurs
    * @param {boolean} repeat - whether or not to repeat the event after it occurs
	  */
  self.addRandomTimedEvent = function(randomStart, randomEnd, func, repeat) {
    var s = function() {return randomStart + Math.random()*(randomEnd-randomStart)};
    self.events.push({type: "timed", random: true, steps: s(), func: func, repeat: repeat, orig: s});
  }
  /** 
    * Adds a condition-based event to the game manager. Can trigger just once or repeatedly.
	  * @memberof GameManager
	  * @param {function} cond - the condition to check
    * @param {function} func - the function to run when the event is triggered
    * @param {boolean} repeat - whether or not to repeat the event after it occurs
    * @param {int} cooldown - if repeating event, cooldown can be optionally used to signify how long to wait until the event can be trigerred again
    * @param {boolean} runFuncAtEndOfCooldown - Whether or not to run the function at the end of the cooldown when an event is triggered instead of the beginning
	  */
  self.addConditionEvent = function(cond, func, repeat, cooldown = 0, runFuncAtEndOfCooldown = false) {
    self.events.push({type: "condition", cond: cond, func: func, repeat: repeat, cooldown: cooldown, random: false, coolingDown: false, runFuncAtEndOfCooldown: runFuncAtEndOfCooldown});
  }
  /** 
    * Adds a condition-based event to the game manager with a random cooldown. Can trigger just once or repeatedly, and can have cooldown between checking if triggered
	  * @memberof GameManager
	  * @param {function} cond - the condition to check
    * @param {function} func - the function to run when the event is triggered
    * @param {boolean} repeat - whether or not to repeat the event after it occurs
    * @param {int} cooldownStart - minimum value to use for cooldown
    * @param {int} cooldownEnd - maximum value to use for cooldown
    * @param {boolean} runFuncAtEndOfCooldown - Whether or not to run the function at the end of the cooldown when an event is triggered instead of the beginning
	  */
  self.addRandomCooldownConditionEvent = function(cond, func, repeat, cooldownStart, cooldownEnd, runFuncAtEndOfCooldown = false) {
    self.events.push({type: "condition", cond: cond, func: func, repeat: repeat, cooldownStart: cooldownStart, cooldownEnd: cooldownEnd, random: true, coolingDown: false, runFuncAtEndOfCooldown: runFuncAtEndOfCooldown});
  }
  
  /**
   * @memberof GameManager
   * events that are ran after the updates (instead of before)
   */
  self.postEvents = [];
  
  /**
   * Adds a event that triggers at the end of the update, before any objects are updated
   * @memberof GameManager
   * @param {function} func - the function to run when the event is triggered
   */
  self.addPostUpdateEvent = function(func, repeat) {
    self.postEvents.push({func: func, repeat: repeat});
  }
}

/** Represents Score
  * @constructor
  * @namespace Score
  * @param {game} game - the game to associate with the score
  * @property {boolean} isCollidable - value if the object can be collided with. Defaults false. 
  * @property {int} score - the value that holds the score number
  * @property {boolean} displayScore - value if the score should be shown or not. Defaults to true.
  * @property {string} scoreColor - value of the color that score wil be draw in. Can be word colors or hex values. Defaults to "black"
  * @property {string} scoreFont - value of the font that score will draw in. Defaults to "bold 12px Palatino Linotype"
  * @property {int} scoreX - the x coordinate of the score. Defaults to zero.
  * @property {int} scoreY - the y coordinate of the score. Defaults to 10.
  */
function Score(game){
	var self = this;
    /** Creates a Score object 
	 *  @constructs Score
	 *  @param {game} game - the game to associate with the score
	 */
	self.constructor = function(game){
		GameObject.call(self, "score", null, 0, 0);
		self.isCollidable=false;
		self.score = 0;
		self.game = game;
		self.displayScore = true;
		self.scoreColor = "black";
		self.scoreFont = "bold 12px Palatino Linotype"
		self.scoreX = 0;
		self.scoreY = 10;
		self.game.score.push(self);
	}
	
	/** Creates the Score object */
	self.constructor(game);
	
	/** Sets if the score is showing on the canvas 
	 *  @memberof Score
	 *  @function setDisplay
	 *  @param {boolean} display - true if you want score to show, false if you want it to disappear, default true
	 */
	self.setDisplay = function(display){
		self.displayScore = display;
	}
	
	/** Sets the color of the Score
	 *  @memberof Score
	 *  @function setColor
	 *  @param {string} color - the name of the color you want the score to be
	 */
	self.setColor = function(color){
		self.scoreColor = color;
	}
	
	/** Sets the font of the Score
	 *  @memberof Score
	 *  @function setFont
	 *  @param {string} font - the font of the color
	 */
	self.setFont = function(font){
		self.scoreFont = font;
	}
	
	/** Sets the x coordinate of the Score
	 *  @memberof Score
	 *  @function setX
	 *  @param {number} x - the x coordinate of the Score
	 */
	self.setX = function(x){
		self.scoreX = x;
	}
	
	/** Sets the y coordinate of the Score
	 *  @memberof Score
	 *  @function setY
	 *  @param {number} y - the y coordinate of the Score
	 */
	self.setY = function(y){
		self.scoreY = y;
	}
	
	/** Adds a number to the score
	 *  @memberof Score
	 *  @function addScore
	 *  @param {number} score - adds this number to the current score
	 */
	self.addScore = function(score){ 
		self.score += score;
	}
	
	/** Subtracts a number to the score
	 *  @memberof Score
	 *  @function substractScore
	 *  @param {number} score - subtracts this number to the current score
	 */
	self.subtractScore = function(score){
		self.score -= score;
	}

  /** Gets the score
   *  @memberof Score
   *  @returns the score
   */
	self.getScore = function() {
		return self.score;
	}
	
  /** Resets the score to 0
   *  @memberof Score
   */
	self.restart = function() {
		self.score = 0;
	}
}

/** Represents HighScore
  * @constructor
  * @namespace HighScore
  * @param {int} max - the max number of high scores to keep track of.
  * @property {int} highScoreMax - the maximum number of high scores to keep track of.
  * @property {array} highScores - the array that holds the high score. Each position in the array holds another array with the value ["name", score].
  */
function HighScore(max){
	var self = this;
	
	 /** Creates a HighScore object 
	 *  @constructs HighScore
	 *  @param {int} max - the max number of high scores to keep track of.
	 */
	self.constructor = function(max){
		self.highScoreMax = max;
		self.highScores = new Array();
		for(var i = 0; i &lt; self.highScoreMax; i++){
		 self.highScores.push(["empty",0]);	
		}	
	}
	
	/** Constructs HighScore */
	self.constructor(max);
	
	/** Returns the high score at some index
	 *  @memberof HighScore
	 *  @function getHighScoreAt
	 *  @param {int} index - the index to get the high score at
	 *  @returns {int} the high score at some index
	 */
	self.getHighScoreAt = function(index){
		return self.highScores[index][1];
	}
	
	/** Returns the name of the high score at some index
	 *  @memberof HighScore
	 *  @function getNameAt
	 *  @param {int} index - the index to get the high score name at
	 *  @returns {String} the name of the high score at some index
	 */
	self.getNameAt = function(index){
		return self.highScores[index][0];
	}
	
	/** Checks if the score given should be in the high score list
	 *  @memberof HighScore
	 *  @function isHighScore
	 *  @param {number} score - the score to check if it should be in the high score list
	 *  @returns {boolean} true if it is a high score or false if it is not
	 */
	self.isHighScore = function(score){
		for(var i = 0; i &lt; self.highScoreMax; i++){
			if(self.getHighScoreAt(i) &lt; score){
				return true;
			}
		}
		return false;
	}
	
	/** Adds the high score to the high score list
	 *  @memberof HighScore
	 *  @function addHighScore
	 *  @param {string} user - the name of the user that got the high score
	 *  @param {number} highscore - the high score
	 */
	self.addHighScore = function(user, highscore){
		for(var i = 0; i &lt; self.highScoreMax; i++){
			if(self.getHighScoreAt(i) &lt; highscore){
				self.highScores.splice(i, 0, [user,highscore]);
				self.highScores.pop();
				break;
			}
		}
	}
	
	/** Saves the high scores list to the local browser
	 *  @memberof HighScore
	 *  @function saveHighScores
	 */
	self.saveHighScores = function(name=""){
		localStorage.setItem("highScores_"+name, JSON.stringify(self.highScores));
	}
	
	/** Gets the high scores list from the local browser
	 *  @memberof HighScore
	 *  @function getHighScores
	 */
	self.getHighScores = function(name=""){
		var json = localStorage.getItem("highScores_"+name);
		if (json)
			return JSON.parse(json);
		return null;
	}
}

/** The life object that places the lives into the game. This is not meant to use directly
  * @mixin
  * @param {sprite} sprite - the sprite that the lives will look like
  * @param {number} x - the x position
  * @param {number} y - the y position
  */
function Life(sprite, x, y){
	var self = this;
  /** constructor
  * @constructs Life
  * @param {sprite} sprite - the sprite that the lives will look like
  * @param {number} x - the x position
  * @param {number} y - the y position
  */
	self.constructor = function(sprite, x, y){
		GameObject.call(self,"life",sprite, x, y);
	}
	self.constructor(sprite, x, y);
}

/** Creates lives that can be seen in the top left hand corner 
  * @class
  * @namespace Lives
  * @param {number} numberOfLives - the maximum number of lives
  * @param {sprite} sprite - the sprite that the lives will look like
  */
function Lives(numberOfLives, sprite){
	var self = this;
	
	/** Creates the Lives class
	  * @constructs Lives
	  * @param {number} numberOfLives - the maximum number of lives
	  * @param {sprite} sprite - the sprite that the lives will look like
	  * @property {int} startX - the starting X value to draw the live sprites at 
	  * @property {array} livesArray - the array that holds the sprites of each life. 
	  */
	self.constructor = function(numberOfLives, sprite){
		GameObject.call(self,"lives",null,0,0);
		var startX = 0;
		self.livesArray = new Array();
		for(var i = 0; i &lt; numberOfLives; i++){
			life = game.objects.push(new Life(sprite, startX, 0));
			self.livesArray.push(life);
			startX += sprite.width;
		}
		self.isCollidable = false;
	}
	
	/** Creates the Lives object */
	self.constructor(numberOfLives, sprite);
	
	/** Removes one life
	  * @memberof Lives
	  * @function loseLife
	  */
	self.loseLife = function(){
		var poppedLife = self.livesArray.pop();
		game.objects.remove(poppedLife);
	}
	
	/** Returns how many lives currently stored
	  * @memberof Lives
	  * @returns {int} the number of lives left
	  */
	self.amountLivesLeft = function(){
		return self.livesArray.length;
	}
	
	/** Restarts the amount of lives to the maximum
	  * @memberof Lives
	  */
	self.restart = function(){
		var startX = 0;
		for(var i = 0; i &lt; numberOfLives; i++){
			life = game.objects.push(new Life(sprite, startX, 0));
			self.livesArray.push(life);
			startX += sprite.width;
		}
	}
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Drawable.html">Drawable</a></li><li><a href="FilledRect.html">FilledRect</a></li><li><a href="Game.html">Game</a></li><li><a href="GameManager.html">GameManager</a></li><li><a href="GameObject.html">GameObject</a></li><li><a href="Grid.html">Grid</a></li><li><a href="HighScore.html">HighScore</a></li><li><a href="Life.html">Life</a></li><li><a href="Lives.html">Lives</a></li><li><a href="Node.html">Node</a></li><li><a href="SceneGraph.html">SceneGraph</a></li><li><a href="Score.html">Score</a></li><li><a href="Sprite.html">Sprite</a></li><li><a href="Vector.html">Vector</a></li></ul><h3>Namespaces</h3><ul><li><a href="Key.html">Key</a></li></ul><h3>Global</h3><ul><li><a href="global.html#flatten">flatten</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Nov 30 2017 17:38:33 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
